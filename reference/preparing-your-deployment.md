---
description: >-
  In this section, you will find more details on how to configure Charles’
  deploy module and how to prepare your application to be available in the
  cluster.
---

# Preparing your deployment

The deployment module monitors and applies the cluster resources. To do that, it uses the [**Operator**](https://kubernetes.io/docs/concepts/extend-kubernetes/operator) pattern that performs reconciliation cycles to make sure that the cluster will always be in the state you need. Kubernetes' logs will also be collected in real-time.

## **Deployment configuration**

Charles has an architecture that adapts to different Kubernetes installations. The only requirement is that your deployment module is installed on the destination cluster with an accessible URL. The deployment configuration indicates what URL is and which Git credentials will be used to search the helm charts. Without this configuration, Charles won't be able to perform deploys. 

### **How can you register the configuration?**

Follow the steps below: 

1. In **Workspaces,** at the left menu, select your workspace and then click on **Settings ;**
2. Click on **Credentials;**
3. Click on **Add Deployment Configuration;**

Fill in these fields:

1. **Butler URL:**  Butler's deploy module URL. If this is in the same Charles' installation cluster, use your FQDN \(Fully Qualified Domain Name\). Example: **http://charlescd-butler.butler-namespace.svc.cluster.local:3000.**
2. **Namespace:** Define the namespace where the resources will be available in the cluster. You have to create your namespace, once Charles does not do it;
3. **Git provider:** defines the git provider you will use ****\(**GitHub or GitLab**\);
4. **Git token:** Insert an authentication token that has access to the git repository where your [**helm templates**](../get-started/creating-your-first-module/) ****are stored \(they will be used during the deployment of your application\). If your Git Provider is **GitHub**, "_repo_" permission is required**.** Otherwise, configure the accesses in **GitLab:** "_API_" and "_read\_repository_".

## **Configuring your application**

The deployment module Butler uses helm charts to make your application available in the cluster.  These charts must be available in a Github or Gitlab repository and accessible through a token, previously registered in the deployment configuration. The URL is provided along with the module registration. 

### **Charts**

The charts must follow the [**Helm pattern**](https://helm.sh/docs/topics/charts/) ****and they need to be contained in a folder with the registered component on Charles. You don't need to run any command to bundle the chart, Charles downloads and it finishes automatically.   
  
See the below an example of a repository containing the component's chart  **http-https-echo** on GitHub:

![](https://lh5.googleusercontent.com/Rt7_Lw1DbK152QKt3brsCYyzF0DAQ4wuoWsdCVyUaZjf9Hlh64EaK7YnHjF16W_xo2BQzlUJyUeUsooPzqwmMIKF7ttUXRej3eM56uWu6WH4QNCiByixeV4zEdHLwEGRq7NCruhH)

### **Templates**

The only requirements for templates to work with Charles are **labels component** and **tag** to be present in the Deployment resource manifests. 

{% hint style="info" %}
It is not necessary to insert the values in the _**values**_ files of your chart, Charles will provide them. 
{% endhint %}

See the example below: 

```text
component: {{ .Values.component }}
tag: {{ .Values.tag }}
```

Butler internally stores the compiled charts in entities that represent each deployment request. Thereby, Charles can perform more efficient rollbacks.

### **Properties injections**

A very important operation that should be considered when preparing your application is the property injection in the manifests performed by Butler. See them below: 

* **name:**  Kubernetes’ resource name. **** Some resources managed by Charles need to have their names altered, in order to make different versions of the same application available in different circles. The property name will have the following value:  ****  **&lt;originalManifest.metadata.name&gt;-&lt;tag&gt;-&lt;deploymentId&gt;** 
* **originalManifest.metadata.name:** Name generated by the application’s chart;
* **tag:** Image’s tag;
* **deploymentId:** Deployment’s entity unique identifier created by Butler.

{% hint style="warning" %}
This update only happens in **Deployment’s** type resources.
{% endhint %}

* **namespace:** Your deployment's namespace. ****This namespace is described during the Workspace configuration and indicates which namespace the deployment will happen. If the charts insert this value in the manifests, Charles will overwrite them. ****
* **labels:** Kubernetes’ resources labels.  
  ****In order to make Butler’s reconciliation cycle and Istio’s routes created correctly work, some labels need to be available in all resources applied to the cluster. See them below:  


  * **deploymentId:** Unique identifier of the deployment's entity created by Butler; 
  * **circleId:** Unique circle's identifier where the deployment will be created. 

  
  
  ****See below an example of a generated manifest after the chart compilation:

```text
apiVersion: apps/v1
kind: Deployment
metadata:
  name: http-https-echo
  labels:
    component: http-https-echo
    tag: v1
spec:
  template:
    metadata:
      name: http-https-echo
      labels:
        component: http-https-echo
        tag: v1
    spec:
      containers:
        - name: http-https-echo
          image: mendhak/http-https-echo:latest
  replicas: 1
  selector:
    matchLabels:
      component: http-https-echo

```

  
  
After the property injection, this same manifest will be:  

```text
apiVersion: apps/v1
kind: Deployment
metadata:
  name: http-https-echo-v1-bc0e1df9-c008-4d86-b534-d782badf3741
  namespace: example-namespace
  labels:
    component: http-https-echo
    tag: v1
    deploymentId: bc0e1df9-c008-4d86-b534-d782badf3741
    circleId: b4b62bc2-4dfd-4673-bc67-cc2cbcf9bb2f
spec:
  template:
    metadata:
      name: http-https-echo
      labels:
        component: http-https-echo
        tag: v1
        deploymentId: bc0e1df9-c008-4d86-b534-d782badf3741
        circleId: b4b62bc2-4dfd-4673-bc67-cc2cbcf9bb2f
    spec:
      containers:
        - name: http-https-echo
          image: mendhak/http-https-echo:latest
  replicas: 1
  selector:
    matchLabels:
      component: http-https-echo

```

After this configuration, you can use Charles to perform deployment in your application in segmented circles. 

